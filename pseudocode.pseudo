// Pseudocode for OneOrZero, a logic gate simulator
import pygame

WIDTH, HEIGHT = 1280, 720
WIN = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("OneOrZero")
WHITE = (255, 255, 255)

FPS = 60

AND_GATE = pygame.image.load("AND_GATE.png")
OR_GATE = pygame.image.load("OR_GATE.png")
NOT_GATE = pyame.image.load("NOT_GATE.png")
NAND_GATE = pygame.image.load("NAND_GATE.png")
NOR_GATE = pygame.image.load("NOR_GATE.png")
XOR_GATE = pygame.image.load("XOR_GATE.png")

SWITCH = pygame.image.load("SWITCH.png")


/* LOGIC GATES
-----------------------------------------------------------------
*/

class LogicGate {
    constructor(self, gateType) {
        self.gateType = gateType
        self.output = 0
    }

    function getOutput(self) {
        self.output = self.performLogic()
        return self.output
    }

    function drawGate(param) {
        
    }
}

class BinaryGate(LogicGate) {
    constructor(self, gateType) {
        super().constructor(gateType)
        self.inputA = 0
        self.inputB = 0
    }

    function getInputA(self, Socket) {
        self.inputA = socket.getState("A")
        return self.inputA
    }

    function getInputB(self, Socket) {
        self.inputB = socket.getState("B")
        return self.inputB
    }
}

class UnaryGate(LogicGate) {
    constructor(self, gateType) {
        super().constructor(gateType)
        self.inputA = 0
    }

    function getInput(self) {
        self.inputA = socketState(socketA)
    }
}

class ANDGate(BinaryGate) {
    constructor(self, gateType) {
        super().constructor(gateType)
    }

    function performLogic(self) {
        if (self.getInputA() == 1) and (self.getInputB() == 1) {
            self.output = 1
        } else {
            self.output = 0
        }
        return self.output
    } 
}

class ORGate(BinaryGate) {
    constructor(self, gateType) {
        super().constructor(gateType)
    }

    function performLogic(self) {
        if (self.getInputA() == 1) or (self.getInputB() == 1) {
            self.output = 1
        } else {
            self.output = 0
        }
        return self.output
    } 
}

class NOTGate(UnaryGate) {
    constructor(self, gateType) {
        super().constructor(gateType)
    }

    function performLogic(self) {
        if (self.getInputA() == 0) {
            self.output = 1
        } else {
            self.output = 0
        }
        return self.output
    } 
}

class NORGate(BinaryGate) {
    constructor(self, gateType) {
        super().constructor(gateType)
    }

    function performLogic(self) {
        if (self.getInputA() == 0) and (self.getInputB() == 0) {
            self.output = 1
        } else {
            self.output = 0
        }
        return self.output
    } 
}

class NANDGate(BinaryGate) {
    constructor(self, gateType) {
        super().constructor(gateType)
    }

    function performLogic(self) {
        if (self.getInputA() == 1) and (self.getInputB() == 1) {
            self.output = 0
        } else {
            self.output = 1
        }
        return self.output
    } 
}

class XORGate(BinaryGate) {
    constructor(self, gateType) {
        super().constructor(gateType)
    }

    function performLogic(self) {
        if ((self.getInputA() == 1) and (self.getInputA() == 0)) or 
        ((self.getInputA() == 0) and (self.getInputA() == 1)) {
            self.output = 1
        } else {
            self.output = 0
        }
        return self.output
    } 
}

/* SIDEBAR MENU
-----------------------------------------------------------------
*/

class SidebarMenu():
    constructor(self,screen, width, height) {
        self.screen = screen
        self.width = width
        self.height = height

        andInstance = new ANDGate(AND_GATE)
        orInstance = new ORGate(OR_GATE)
        notInstance = new NOTGate(NOT_GATE)
        nandInstance = new NANDGate(NAND_GATE)
        norInstance = new NORGate(NOR_GATE)
        xorInstance = new XORGate(XOR_GATE)

        switchInstance = new Switch(SWITCH)
    }

    componentsList = [andInstance, orInstance, notInstace,
    nandInstance, norInstance, xorInstance, switchInstance]
    // Y-value of each component
    coordinatesDictionary = {"andInstance" : 0, "orInstance" : 60,
     "notInstance" : 120, "nandInstance": 180, "norInstance" : 240, 
     "nandInstance" : 300, "xorInstance" : 360, "switchInstance" : 420}
    // Displays the gates in the sidebar menu, in a 1x6 grid
    procedure drawGates(self) {
        pygame.draw.rect(self.screen, (192, 192, 192), pygame.Rect(0, 0, self.width, self.height))
        for item in componentsList:
            coordinates = coordinatesDictionary[str(item)]
            WIN.blit(item, coordinates)
    }
    // This function checks that a logic gate is clicked.
    function buttonClicked(self) {
        for button in componentsList:
            if coordinatesDictionary[button].collidepoint(pos):
                return True
        return None
    }

/* SOCKET CLASS
-----------------------------------------------------------------
*/
class Socket {
    constructor(self,screen, x, y, input = False) {
        self.screen = screen
        self.x = x
        self.y = y
        self.radius = 10
        self.color = (255, 255, 255)
        self.input = input
        self.clicked = False
    }

    procedure draw(self) {
        pygame.draw.circle(self.screen, self.color, (self.x, self.y), self.radius)
        if self.input == True:
            pygame.draw.circle(self.screen, (0, 0, 0), (self.x, self.y), self.radius-2)
    }
    // Checks collision
    procedure handleEvent(self, event) {
        if event.type == pygame.MOUSEBUTTONUP:
            pos = pygame.mouse.getPos()
            if (pos[0] - self.x)**2 + (pos[1] - self.y)**2 <= self.radius**2:
                self.clicked = True
    }
}
/* WIRE CLASS
-----------------------------------------------------------------
*/
class Wire:
    constructor(self, screen, socket1, socket2):
        self.screen = screen
        self.socket1 = socket1
        self.socket2 = socket2
        self.color = (255, 255, 255)
        self.width = 2

    function draw(self){
        pygame.draw.line(self.screen, self.color, (self.socket1.x, self.socket1.y), (self.socket2.x, self.socket2.y), self.width)
    }
    function update(self){
        self.draw()
    }

/* GAME CLASS
-----------------------------------------------------------------
*/
class Game():
    constructor() {
        pygame.init()
    }

running = True

function dragAndDrop() {
    if event.type == pygame.MOUSEBUTTONDOWN:
        if event.button == 1:
            if SidebarMenu.buttonClicked(self) == True:
                dragging = True
                mouseX = event.pos
                mouseY = event.pos
                offsetX = self.x - mouseX
                offsetY = self.y - mouseY
                return offsetX, offsetY

    else if event.type == pygame.MOUSEMOTION:
        if dragging == True:
            mouseX = event.pos
            mouseY = event.pos
            offsetX = self.x + mouseX
            offsetY = self.y + mouseY
            return offsetX, offsetY
    else:
        return None
}

function main() {
    while running == True:
        for event in pygame.event.get():
            // Checks if the program was quit
            if event.type == pygame.QUIT:
                running = False

            dragAndDrop()

        WIN.fill(WHITE)
        pygame.display.update()
    
}

main()